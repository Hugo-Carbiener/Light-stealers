using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraManager : MonoBehaviour{    [Header("Move controls")]    [SerializeField] private float VerticalSpeed;    [SerializeField] private float lateralSpeed;    [Header("Move bounds")]    [SerializeField] private Vector2 minBounds;    [SerializeField] private Vector2 maxBounds;    Vector2 frameMove;    private void Start()    {        // set components        TilemapManager tilemapManager = TilemapManager.Instance;        GridLayout grid = TilemapManager.Instance.grid;        // component position        Vector3Int initialCameraPosition = new Vector3Int(TilemapManager.Instance.GetTilemapColumns() / 2, TilemapManager.Instance.GetTilemapRows() / 2, 0);        transform.position = TilemapManager.Instance.groundTilemap.CellToWorld(initialCameraPosition);        // move bounds        minBounds = Vector2.zero;        maxBounds = new Vector2(grid.cellSize.y * tilemapManager.GetTilemapColumns() * 3 / 4, grid.cellSize.x * tilemapManager.GetTilemapRows());    }    private void OnEnable()    {        InputManager.onMoveInput += updateFrameMove;    }    private void OnDisable()    {        InputManager.onMoveInput -= updateFrameMove;    }    private void updateFrameMove(Vector2 moveVector)    {        frameMove += moveVector;    }    private void LateUpdate()    {        if(frameMove != Vector2.zero)        {            Vector2 speedModFrameMove = new Vector2(frameMove.x * lateralSpeed, frameMove.y * VerticalSpeed);            transform.position += transform.TransformDirection(speedModFrameMove) * Time.deltaTime;            LockPositionInBounds();            frameMove = Vector2.zero;            if (TileSelectionManager.Instance.GetSelectedCellData() != null)
            {
                BuildingUIManager.Instance.UpdateWorldPosition();
            }        }    }    private void LockPositionInBounds()    {        transform.position = new Vector2(            Mathf.Clamp(transform.position.x, minBounds.x, maxBounds.x),            Mathf.Clamp(transform.position.y, minBounds.y, maxBounds.y)            );    }}